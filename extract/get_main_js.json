{"extracted_information": "// --- Three.js Setup ---\nlet scene, camera, renderer;\n// --- Cannon.js Setup ---\nlet world;\nlet playerBody;\nconst playerMass = 70; // kg\nconst playerRadius = 0.5; // meters\nconst playerEyeHeight = 1.6; // meters, camera height offset from playerBody center\n// --- Controls ---\nlet controlsEnabled = false;\nlet moveForward = false;\nlet moveBackward = false;\nlet moveLeft = false;\nlet moveRight = false;\nlet canJump = false;\nlet isOnGround = false;\nconst playerMoveSpeed = 5.0; // m/s\nconst playerJumpVelocity = 5.0; // m/s\nconst clock = new THREE.Clock();\nconst cannonStep = 1 / 60;\n// Mouse look controls helper\nconst _euler = new THREE.Euler(0, 0, 0, 'YXZ');\nconst _PI_2 = Math.PI / 2;\nconst minPitchAngle = -_PI_2 + 0.01; // Min pitch (looking almost straight down)\nconst maxPitchAngle = _PI_2 - 0.01; // Max pitch (looking almost straight up)\nfunction init() {\n// Scene\nscene = new THREE.Scene();\nscene.background = new THREE.Color(0x000000); // Deep black background\n// Camera\ncamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n// Camera position will be updated by playerBody\n// Renderer\nrenderer = new THREE.WebGLRenderer({ antialias: true });\nrenderer.setSize(window.innerWidth, window.innerHeight);\nrenderer.shadowMap.enabled = true;\ndocument.body.appendChild(renderer.domElement);\n// --- Gallery Dimensions ---\nconst hallSize = 20; // Overall size of the square hall (e.g., 20x20)\nlet wallHeight = 3; // Height of the walls - will be doubled\nwallHeight *= 2;\nconst halfHallSize = hallSize / 2; // Thickness can be defined later when walls are actually created\n// Lighting\n// Ambient light provides a very subtle base illumination\nconst ambientLight = new THREE.AmbientLight(0xffffff, 0.15); // Reduced significantly\nscene.add(ambientLight);\n// Directional light (simulating external light, now very minimal)\nconst directionalLight = new THREE.DirectionalLight(0xffffff, 0.05); // Further dimmed\ndirectionalLight.position.set(10, 15, 10);\n// directionalLight.castShadow = false; // External light probably shouldn't cast detailed shadows inside\nscene.add(directionalLight);\n// Gallery Interior Lights (SpotLights)\nconst spotLightY = wallHeight - 0.5; // Position spotlights just below the NEW, TALLER ceiling\nconst spotLightProperties = {\ncolor: 0xffeedd, // Warm white\nintensity: 1.5, // Adjusted intensity\ndistance: hallSize * 0.8, // Effective distance\nangle: Math.PI / 6, // Cone angle (approx 30 degrees) - Increased for wider spread\npenumbra: 0.6, // Softness of the edge - Increased for softer edges\ndecay: 2 // Physical falloff\n};\nconst createSpotlight = (x, y, z, targetX, targetY, targetZ) => {\nconst light = new THREE.SpotLight(\nspotLightProperties.color,\nspotLightProperties.intensity,\nspotLightProperties.distance,\nspotLightProperties.angle,\nspotLightProperties.penumbra,\nspotLightProperties.decay\n);\nlight.position.set(x, y, z);\nlight.target.position.set(targetX, targetY, targetZ);\nscene.add(light.target); // Target must be added to the scene\nlight.castShadow = true;\nlight.shadow.mapSize.width = 1024;\nlight.shadow.mapSize.height = 1024;\nlight.shadow.camera.near = 0.5;\nlight.shadow.camera.far = spotLightProperties.distance;\n// light.shadow.focus = 1; // For sharper shadows, if needed\nscene.add(light);\nreturn light;\n};\nconst wallTargetY = wallHeight / 2.5; // Target lights towards typical artwork height\nconst spotLightOffsetFromWall = 2;\nconst zPositions = [-hallSize / 3.5, 0, hallSize / 3.5]; // 3 lights per wall\n// Spotlights for +X wall (Wall at x = hallSize / 2)\nzPositions.forEach(zPos => {\ncreateSpotlight(\nhallSize / 2 - spotLightOffsetFromWall, spotLightY, zPos, // Light position\nhallSize / 2, wallTargetY, zPos // Target position on the wall\n);\n});\n// Spotlights for -X wall (Wall at x = -hallSize / 2)\nzPositions.forEach(zPos => {\ncreateSpotlight(\n-hallSize / 2 + spotLightOffsetFromWall, spotLightY, zPos, // Light position\n-hallSize / 2, wallTargetY, zPos // Target position on the wall\n);\n});\n// Spotlights for +Z wall (Wall at z = hallSize / 2)\nconst xPositions = [-hallSize / 3.5, 0, hallSize / 3.5];\nxPositions.forEach(xPos => {\ncreateSpotlight(\nxPos, spotLightY, hallSize / 2 - spotLightOffsetFromWall, // Light position\nxPos, wallTargetY, hallSize / 2 // Target position on the wall\n);\n});\n// Spotlights for -Z wall (Wall at z = -hallSize / 2)\nxPositions.forEach(xPos => {\ncreateSpotlight(\nxPos, spotLightY, -hallSize / 2 + spotLightOffsetFromWall, // Light position\nxPos, wallTargetY, -hallSize / 2 // Target position on the wall\n);\n});\n// Central Ceiling Light for overall ambiance\nconst centralLight = new THREE.PointLight(0xfff5e1, 0.25, hallSize * 1.2, 2); // Warmish white, weak, covers gallery, physical decay\ncentralLight.position.set(0, wallHeight - 0.3, 0); // Just below NEW, TALLER ceiling center\ncentralLight.castShadow = false; // No shadows for this ambient light\nscene.add(centralLight);\n// --- Cannon.js World Setup ---\nworld = new CANNON.World();\nworld.gravity.set(0, -9.82, 0);\nworld.broadphase = new CANNON.NaiveBroadphase();\nworld.solver.iterations = 10; // Improve solver accuracy\n// Ground\nconst groundShape = new CANNON.Plane();\nconst groundBody = new CANNON.Body({ mass: 0 });\ngroundBody.addShape(groundShape);\ngroundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);\nworld.addBody(groundBody);\nconst groundGeometry = new THREE.PlaneGeometry(100, 100);\nconst textureLoader = new THREE.TextureLoader();\nconst woodFloorTexture = textureLoader.load('https://cdn.polyhaven.com/asset_img/primary/wood_planks.png?height=720', function(texture) {\ntexture.wrapS = texture.wrapT = THREE.RepeatWrapping;\ntexture.repeat.set((hallSize / 4) * 10, (hallSize / 4) * 10); // Increase tiling by 10x\ntexture.anisotropy = renderer.capabilities.getMaxAnisotropy(); // Improve texture quality at glancing angles\ntexture.needsUpdate = true;\n});\nconst groundMaterial = new THREE.MeshStandardMaterial({\nmap: woodFloorTexture,\nside: THREE.DoubleSide,\nroughness: 0.8, // Adjust for desired wood shininess\nmetalness: 0.1 // Wood is not very metallic\n});\nconst groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);\ngroundMesh.rotation.x = -Math.PI / 2;\ngroundMesh.receiveShadow = true;\nscene.add(groundMesh);\n// Gallery Bench (Legless and Scaled)\nconst benchMaterial = new THREE.MeshStandardMaterial({ color: 0x5A5A5A, roughness: 0.7, metalness: 0.2 }); // Dark grey\nconst benchScaleFactor = 3.0;\nlet originalSeatHeight = 0.4; // Will be halved\noriginalSeatHeight /= 2;\nconst originalSeatWidth = 2.0;\nconst originalSeatDepth = 0.5;\nconst seatHeight = originalSeatHeight * benchScaleFactor;\nconst seatWidth = originalSeatWidth * benchScaleFactor;\nconst seatDepth = originalSeatDepth * benchScaleFactor;\n// Three.js Bench Mesh (just the seat)\nconst benchGroup = new THREE.Group(); // Still use a group in case we want to rotate the whole bench later\nbenchGroup.position.set(0, 0, 0); // Bench at gallery center, on the ground.\nscene.add(benchGroup);\nconst seatGeo = new THREE.BoxGeometry(seatWidth, seatHeight, seatDepth);\nconst seatMesh = new THREE.Mesh(seatGeo, benchMaterial);\nseatMesh.position.y = seatHeight / 2; // Seat rests directly on the ground\nseatMesh.castShadow = true;\nseatMesh.receiveShadow = true;\nbenchGroup.add(seatMesh);\n// Cannon.js Bench Physics Body (just the seat)\nconst benchBody = new CANNON.Body({ mass: 0 }); // Static body\nconst seatShape = new CANNON.Box(new CANNON.Vec3(seatWidth / 2, seatHeight / 2, seatDepth / 2));\n// The position of the seat shape is relative to the benchBody's origin (which is at 0,0,0 on the ground)\n// Since the benchBody itself is at y=0, and the seatMesh is also positioned with its bottom at y=0 relative to the group,\n// the shape's offset y should also be seatHeight / 2.\nbenchBody.addShape(seatShape, new CANNON.Vec3(0, seatHeight / 2, 0));\nbenchBody.position.set(0, 0, 0); // Matches benchGroup's initial position (on the ground at gallery center)\nworld.addBody(benchBody);\n// Ceiling\nconst ceilingSize = hallSize; // Ceiling covers the whole hall\nconst ceilingYPos = wallHeight;\n// Three.js Ceiling Mesh\nconst ceilingGeometry = new THREE.PlaneGeometry(ceilingSize, ceilingSize);\nconst ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0x050505, side: THREE.DoubleSide }); // Very dark grey\nconst ceilingMesh = new THREE.Mesh(ceilingGeometry, ceilingMaterial);\nceilingMesh.position.set(0, ceilingYPos, 0);\nceilingMesh.rotation.x = Math.PI / 2; // Rotate to be horizontal, facing downwards by default from this rotation\nceilingMesh.receiveShadow = true; // Optional, if lights are added above pointing down\nscene.add(ceilingMesh);\n// Cannon.js Ceiling Physics Body\nconst ceilingShape = new CANNON.Plane();\nconst ceilingBody = new CANNON.Body({ mass: 0 }); // Static body\nceilingBody.addShape(ceilingShape);\nceilingBody.position.set(0, ceilingYPos, 0);\n// Rotate the Cannon.js plane so its normal points downwards (-Y direction)\nceilingBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);\nworld.addBody(ceilingBody);\n// Ceiling stars removed as per request.\n// Player Physics Body\nconst playerShape = new CANNON.Sphere(playerRadius);\nplayerBody = new CANNON.Body({\nmass: playerMass,\nshape: playerShape,\nposition: new CANNON.Vec3(0, playerRadius + 0.1, 5), // Start slightly above ground\nlinearDamping: 0.9, // To prevent sliding forever\nangularDamping: 1.0 // To prevent spinning from collisions\n});\nplayerBody.addEventListener(\"collide\", onPlayerCollision);\nworld.addBody(playerBody);\n// Example Box has been removed.\n// Create Walls\nconst wallMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });\nconst wallThickness = 0.5; // meters\n// hallSize and wallHeight are now defined earlier, before the Lighting section.\n// Artwork Placeholders\n// const artworkPlaceholderMaterial = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.9 }); // Commented out\nconst artworkImageUrls = [\n'images/artwork1.jpg',\n'images/artwork2.jpg',\n'images/artwork3.jpg',\n'images/artwork4.jpg',\n'images/artwork5.jpg',\n'images/artwork6.jpg',\n'images/artwork7.jpg',\n'images/artwork8.jpg',\n'images/artwork9.jpg',\n'images/artwork10.jpg',\n'images/artwork11.jpg',\n'images/artwork12.jpg'\n];\n// textureLoader is already defined globally for the floor texture\nconst artworkDepth = 0.05; // Slight extrusion from the wall\n// Base height for all artworks. Width will be calculated based on aspect ratio to prevent stretching.\nconst baseArtworkHeight = 2.5; // A standard height for all artwork canvases.\nconst artworkYPos = wallHeight / 2.2;\nconst createArtwork = (x, y, z, rotationY, imageUrl) => {\n// Create a group to hold the artwork. This allows us to position and rotate it\n// immediately, and then add the mesh asynchronously once the texture loads.\nconst artworkGroup = new THREE.Group();\nartworkGroup.position.set(x, y, z);\nartworkGroup.rotation.y = rotationY;\nscene.add(artworkGroup);\nif (imageUrl) {\ntextureLoader.load(\nimageUrl,\n// onLoad callback\n(texture) => {\ntexture.colorSpace = THREE.SRGBColorSpace;\n// Calculate aspect ratio from the loaded image\nconst aspectRatio = texture.image.naturalWidth / texture.image.naturalHeight;\n// Calculate dimensions based on the base height and aspect ratio\nconst artworkHeight = baseArtworkHeight;\nconst artworkWidth = artworkHeight * aspectRatio;\n// Create geometry with the correct aspect ratio\nconst artworkGeo = new THREE.BoxGeometry(artworkWidth, artworkHeight, artworkDepth);\nconst artworkMaterial = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.7, metalness: 0.1 });\nconst artworkMesh = new THREE.Mesh(artworkGeo, artworkMaterial);\nartworkMesh.castShadow = true;\nartworkMesh.receiveShadow = true;\n// Add the mesh to the group. Its position is relative to the group, so (0,0,0) is correct.\nartworkGroup.add(artworkMesh);\n},\n// onProgress callback (optional)\nundefined,\n// onError callback\n(err) => {\nconsole.error(`An error occurred loading artwork: ${imageUrl}`, err);\n// Add a reddish placeholder to the group on error to make it noticeable\nconst fallbackGeo = new THREE.BoxGeometry(baseArtworkHeight * 0.75, baseArtworkHeight, artworkDepth);\nconst fallbackMaterial = new THREE.MeshStandardMaterial({ color: 0x550000 });\nconst fallbackMesh = new THREE.Mesh(fallbackGeo, fallbackMaterial);\nartworkGroup.add(fallbackMesh);\n}\n);\n} else {\n// Synchronously create a fallback placeholder if no image URL is provided\nconst fallbackGeo = new THREE.BoxGeometry(baseArtworkHeight * 0.75, baseArtworkHeight, artworkDepth); // Default size\nconst fallbackMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9, metalness: 0.0 });\nconst fallbackMesh = new THREE.Mesh(fallbackGeo, fallbackMaterial);\nartworkGroup.add(fallbackMesh);\n}\n};\n// --- Artwork Placement ---\n// All positions are relative to the gallery center (0,0,0), where the bench is.\n// Artworks are placed so their back is flush with the inner surface of the walls.\n// Helper to get the next image URL, or null if we've used them all\nlet artIndex = 0;\nconst getNextImageUrl = () => (artIndex < artworkImageUrls.length) ? artworkImageUrls[artIndex++] : null;\nconst ARTWORK_PLACEMENT_Y = artworkYPos; // artworkYPos is defined earlier as wallHeight / 2.2\nconst ARTWORK_PLACEMENT_Y_HIGH = 4.5; // For the specific high-placed artwork\n// Define an offset to move artworks from the wall surface towards the gallery center.\nconst artworkOffsetFromWallTowardCenter = 0.3; // Adjusted: 0.7m from wall towards center.\n// Calculate the base distance from the gallery center (0,0,0) to where the artwork's center will be.\n// This accounts for hall size, wall thickness, artwork depth, and the new offset.\nconst artworkCenterCoordinateMagnitude = hallSize / 2 - wallThickness / 2 - artworkDepth / 2 - artworkOffsetFromWallTowardCenter;\n// Coordinates for artwork centers on walls along negative and positive axes.\nconst ART_PLACEMENT_NEG_AXIS = -artworkCenterCoordinateMagnitude;\nconst ART_PLACEMENT_POS_AXIS = artworkCenterCoordinateMagnitude;\n// Define offsets for placing artworks along the length of a wall (relative to wall center)\nconst ALONG_WALL_OFFSET_CENTER = 0;\nconst ALONG_WALL_OFFSET_SIDE = hallSize / 3.5; // e.g., positions at -5 and +5 for hallSize 20\nconst ALONG_WALL_OFFSET_BACK_HIGH_LEFT_X = -hallSize / 8; // e.g., -2.5 for the high-left artwork\n// --- Create Artworks (3 per wall) ---\n// Back wall artworks (-Z wall, facing +Z)\ncreateArtwork(-ALONG_WALL_OFFSET_SIDE, ARTWORK_PLACEMENT_Y, ART_PLACEMENT_NEG_AXIS, 0, getNextImageUrl());\ncreateArtwork( ALONG_WALL_OFFSET_SIDE, ARTWORK_PLACEMENT_Y, ART_PLACEMENT_NEG_AXIS, 0, getNextImageUrl());\ncreateArtwork( ALONG_WALL_OFFSET_CENTER, ARTWORK_PLACEMENT_Y, ART_PLACEMENT_NEG_AXIS, 0, getNextImageUrl());\n// Front wall artworks (+Z wall, facing -Z)\ncreateArtwork(-ALONG_WALL_OFFSET_SIDE, ARTWORK_PLACEMENT_Y, ART_PLACEMENT_POS_AXIS, Math.PI, getNextImageUrl());\ncreateArtwork( ALONG_WALL_OFFSET_SIDE, ARTWORK_PLACEMENT_Y, ART_PLACEMENT_POS_AXIS, Math.PI, getNextImageUrl());\ncreateArtwork( ALONG_WALL_OFFSET_CENTER, ARTWORK_PLACEMENT_Y, ART_PLACEMENT_POS_AXIS, Math.PI, getNextImageUrl()); // Moved from back wall\n// Left wall artworks (-X wall, facing +X)\ncreateArtwork(ART_PLACEMENT_NEG_AXIS, ARTWORK_PLACEMENT_Y, -ALONG_WALL_OFFSET_SIDE, Math.PI / 2, getNextImageUrl());\ncreateArtwork(ART_PLACEMENT_NEG_AXIS, ARTWORK_PLACEMENT_Y, ALONG_WALL_OFFSET_CENTER, Math.PI / 2, getNextImageUrl());\ncreateArtwork(ART_PLACEMENT_NEG_AXIS, ARTWORK_PLACEMENT_Y, ALONG_WALL_OFFSET_SIDE, Math.PI / 2, getNextImageUrl());\n// Right wall artworks (+X wall, facing -X)\ncreateArtwork(ART_PLACEMENT_POS_AXIS, ARTWORK_PLACEMENT_Y, -ALONG_WALL_OFFSET_SIDE, -Math.PI / 2, getNextImageUrl());\ncreateArtwork(ART_PLACEMENT_POS_AXIS, ARTWORK_PLACEMENT_Y, ALONG_WALL_OFFSET_CENTER, -Math.PI / 2, getNextImageUrl());\ncreateArtwork(ART_PLACEMENT_POS_AXIS, ARTWORK_PLACEMENT_Y, ALONG_WALL_OFFSET_SIDE, -Math.PI / 2, getNextImageUrl());\nfunction createWall(width, height, depth, x, y, z, rotationY = 0) {\n// Three.js Wall\nconst wallGeo = new THREE.BoxGeometry(width, height, depth);\nconst wallMesh = new THREE.Mesh(wallGeo, wallMaterial);\nwallMesh.position.set(x, y, z);\nif (rotationY !== 0) wallMesh.rotation.y = rotationY;\nwallMesh.castShadow = true;\nwallMesh.receiveShadow = true;\nscene.add(wallMesh);\n// Cannon.js Wall\nconst wallShape = new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2));\nconst wallBody = new CANNON.Body({ mass: 0 }); // Static body\nwallBody.addShape(wallShape);\nwallBody.position.set(x, y, z);\nif (rotationY !== 0) wallBody.quaternion.setFromEuler(0, rotationY, 0);\nworld.addBody(wallBody);\n}\n// const halfHallSize = hallSize / 2; // Moved to the top of init()\nconst wallYPos = wallHeight / 2;\n// Front Wall (positive Z)\ncreateWall(hallSize, wallHeight, wallThickness, 0, wallYPos, halfHallSize - wallThickness / 2);\n// Back Wall (negative Z)\ncreateWall(hallSize, wallHeight, wallThickness, 0, wallYPos, -halfHallSize + wallThickness / 2);\n// Right Wall (positive X)\ncreateWall(wallThickness, wallHeight, hallSize, halfHallSize - wallThickness / 2, wallYPos, 0, 0);\n// Left Wall (negative X)\ncreateWall(wallThickness, wallHeight, hallSize, -halfHallSize + wallThickness / 2, wallYPos, 0, 0);\n// Pointer Lock Controls Setup\nconst instructions = document.createElement('div');\ninstructions.innerHTML = 'Click to play';\ninstructions.style.position = 'absolute';\ninstructions.style.top = '50%';\ninstructions.style.left = '50%';\ninstructions.style.transform = 'translate(-50%, -50%)';\ninstructions.style.fontSize = '24px';\ninstructions.style.color = 'white';\ninstructions.style.backgroundColor = 'rgba(0,0,0,0.5)';\ninstructions.style.padding = '10px';\ninstructions.style.cursor = 'pointer';\ndocument.body.appendChild(instructions);\ninstructions.addEventListener('click', () => {\ndocument.body.requestPointerLock();\n});\ndocument.addEventListener('pointerlockchange', onPointerLockChange, false);\ndocument.addEventListener('pointerlockerror', onPointerLockError, false);\ndocument.addEventListener('mousemove', onMouseMove, false);\ndocument.addEventListener('keydown', onKeyDown, false);\ndocument.addEventListener('keyup', onKeyUp, false);\nwindow.addEventListener('resize', onWindowResize, false);\nanimate();\n}\nfunction onPointerLockChange() {\nif (document.pointerLockElement === document.body) {\ncontrolsEnabled = true;\nconst instructions = document.querySelector('div[style*=\"absolute\"]');\nif (instructions) instructions.style.display = 'none';\n} else {\ncontrolsEnabled = false;\nconst instructions = document.querySelector('div[style*=\"absolute\"]');\nif (instructions) instructions.style.display = 'block';\n}\n}\nfunction onPointerLockError() {\nconsole.error('PointerLock Error');\n}\nfunction onMouseMove(event) {\nif (!controlsEnabled) return;\nconst movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;\nconst movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;\n_euler.setFromQuaternion(camera.quaternion); // Get current camera orientation\n_euler.y -= movementX * 0.002; // Yaw (rotation around Y axis)\n_euler.x -= movementY * 0.002; // Pitch (rotation around X axis)\n// Clamp pitch angle\n_euler.x = Math.max(minPitchAngle, Math.min(maxPitchAngle, _euler.x));\ncamera.quaternion.setFromEuler(_euler); // Apply the new orientation\n}\nfunction onKeyDown(event) {\nswitch (event.code) {\ncase 'KeyW': moveForward = true; break;\ncase 'KeyA': moveLeft = true; break;\ncase 'KeyS': moveBackward = true; break;\ncase 'KeyD': moveRight = true; break;\ncase 'Space': if (isOnGround) canJump = true; break;\n}\n}\nfunction onKeyUp(event) {\nswitch (event.code) {\ncase 'KeyW': moveForward = false; break;\ncase 'KeyA': moveLeft = false; break;\ncase 'KeyS': moveBackward = false; break;\ncase 'KeyD': moveRight = false; break;\n}\n}\nfunction onPlayerCollision({ contact }) {\n// Check if the contact normal is pointing upwards, indicating we are on something.\nconst contactNormal = new CANNON.Vec3();\nconst upAxis = new CANNON.Vec3(0, 1, 0);\n// contact.bi and contact.bj are the colliding bodies\n// contact.ni is the contact normal\n// We need to check if the normal is against the player's direction of gravity\nif (contact.bi.id === playerBody.id) { // If body A is the player\ncontact.ni.negate(contactNormal); // Normal points away from body A\n} else { // If body B is the player\ncontactNormal.copy(contact.ni); // Normal points away from body A (towards B)\n}\n// If the dot product is high, it means we are on a fairly flat surface\nif (contactNormal.dot(upAxis) > 0.5) {\nisOnGround = true;\n}\n}\nfunction updatePlayer(deltaTime) {\nif (!controlsEnabled && !playerBody) return;\nconst inputVelocity = new THREE.Vector3();\n// Create a temporary Euler angle to get the current camera yaw\nconst cameraEuler = new THREE.Euler(0, 0, 0, 'YXZ');\ncameraEuler.setFromQuaternion(camera.quaternion); // Get current orientation from the camera's quaternion\n// We only want the yaw component (rotation around Y axis) for movement direction.\n// Create a new Euler with only the yaw from the camera.\nconst movementEuler = new THREE.Euler(0, cameraEuler.y, 0, 'YXZ');\nif (moveForward) inputVelocity.z = -playerMoveSpeed;\nif (moveBackward) inputVelocity.z = playerMoveSpeed;\nif (moveLeft) inputVelocity.x = -playerMoveSpeed;\nif (moveRight) inputVelocity.x = playerMoveSpeed;\n// Apply the camera's YAW rotation to the movement vector\ninputVelocity.applyEuler(movementEuler);\nplayerBody.velocity.x = inputVelocity.x;\nplayerBody.velocity.z = inputVelocity.z;\nif (canJump && isOnGround) {\nplayerBody.velocity.y = playerJumpVelocity;\ncanJump = false;\nisOnGround = false; // Assume we are not on ground immediately after jump\n}\n}\nfunction onWindowResize() {\ncamera.aspect = window.innerWidth / window.innerHeight;\ncamera.updateProjectionMatrix();\nrenderer.setSize(window.innerWidth, window.innerHeight);\n}\nfunction animate() {\nrequestAnimationFrame(animate);\nconst deltaTime = clock.getDelta();\nif (controlsEnabled || document.pointerLockElement === document.body) {\nupdatePlayer(deltaTime);\n}\n// Step the physics world\nif (world) {\nworld.step(cannonStep, deltaTime, 3);\n// Update Three.js meshes based on Cannon.js bodies (e.g., the example box)\n// Update Three.js meshes based on Cannon.js bodies (if any other than player)\nscene.traverse(function(object) {\n// Ensure we are not trying to update the player's visual representation here,\n// as the camera itself is the player's visual representation in FPV.\n// If we had a visible player model, we would update it here.\n// For now, this loop might only be relevant if we add other dynamic physics objects.\nif (object.isMesh && object.userData.physicsBody && object.userData.physicsBody !== playerBody) {\nobject.position.copy(object.userData.physicsBody.position);\nobject.quaternion.copy(object.userData.physicsBody.quaternion);\n}\n});\n// Update camera position to player body\nif (playerBody) {\nconst targetPosition = new THREE.Vector3();\ntargetPosition.copy(playerBody.position);\ntargetPosition.y += playerEyeHeight;\ncamera.position.lerp(targetPosition, 0.2); // Adjust 0.2 for more/less smoothing\n}\n}\nrenderer.render(scene, camera);\n}\ninit();"}